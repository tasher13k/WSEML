%! Author = dlebedin
%! Date = 31.01.2022

\documentclass{report}
\usepackage[utf8]{inputenc}
\usepackage[english,russian]{babel}
\setlength{\textheight}{27truecm}
\setlength{\textwidth}{19truecm}
\setlength{\oddsidemargin}{-1.5truecm}
\setlength{\topmargin}{-3truecm}
\begin{document}

    Задание 6. 

    1) Модификаторы константности const и mutable (нужны в том числе для компиляции --- компиляция постоянных команд проще). Эти модификаторы помечают объекты, распространяясь и на их содержимое, не находящееся под действием другого модификатора.

    2) Транзакции.

    Написать следующие команды:
    \begin{center}
    \begin{tabular}{|l|p{10cm}|}
        \hline
        Синтаксис&Смысл команды\\
        \hline
        \verb|[указатель, N]st|&начало транзакции в поддереве с корнем по указанному адресу, может быть вложенным, но транзакции по поддеревьям должны быть вложенными в транзакции по наддеревьям (вложенные начинаются не раньше, и заканчиваются не позже, чем объемлющие)\\
        \verb|[указатель, N]rb|&отменить изменения в поддереве с корнем по указанному адресу --- обязательно после st на том же указателе\\
        \verb|[указатель, N]cm|&принять изменения в поддереве с корнем по указанному адресу --- обязательно после st на том же указателе\\
        \hline
    \end{tabular}
    \end{center}

    3) Ссылки типа ''мешок''.

    Определить операции чтения и записи ссылок разновидности m (дополнительная информация --- ссылка на объект с данными (список)) --- мешок. Запись в такую ссылку означает дописать в конец списка по указанному адресу, и предоставить всем наблюдателям новое значение; чтение из такой ссылки --- размножить текущий стек по числу элементов в таком списке; в каждый из результирующих стеков вернуть очередное значение из этого списка как результат операции чтения из мешка; кроме того, добавить наблюдателя (нерабочий стек) таким образом, чтобы при добавлении в мешок нового значения этот нерабочий стек копировался, и в полученный стек (уже рабочий) возвращалось новое значение, добавленное в мешок.

    4) Команды match и объекты исследования как конечные автоматы.

    Написать диспетчер команд типа mt, первым элементом которых является шаблон (объект с дырками типа ph в самом значении и в его типе) и запускающий все команды из таблицы, шаблоны в которых являются частными случаями шаблона из той команды, которая должна быть выполнена, вида
    \begin{center}
        \verb|[[шаблон_значения]шаблон_типа, объект_поиска, R, N]mt|
    \end{center}
    \begin{center}
    \begin{tabular}{|l|p{10cm}|}
        \hline
        \verb|[[S]verbatim, объект_поиска, N]mt|&прочитать строку S как есть (дословно) в объекте поиска (для строки) или умереть, если там нет такой строки\\
        \verb|[[S]integer, объект_поиска, R, N]mt|&прочитать целое число S как есть (дословно) в объекте поиска (для строки) или умереть, если там нет такого числа (эта команда представляет собой частный случай следующей, поэтому если следующая команда должна будет быть запущена, реализация этой тоже будет запущена одновременно)\\
        \verb|[[[указатель]ph]integer, объект_поиска, R, N]mt|&прочитать любое целое число в объекте поиска (для строки) и записать его по указателю (а в R попадает вся конструкция целиком) или умереть, если там нет никакого целого числа (именно реализация данной функции и определяет, что такое целое число)\\
        \verb|[[S]real, объект_поиска, R, N]mt|&прочитать вещественное число S как есть (дословно) в объекте поиска (для строки) или умереть, если там нет такого числа\\
        \verb|[[[указатель]ph]real, объект_поиска, R, N]mt|&прочитать любое вещественное число в объекте поиска (для строки) и записать его по указателю (а в R попадает вся конструкция целиком) или умереть, если там нет никакого вещественного числа\\
        \verb|[[S]identifier, объект_поиска, R, N]mt|&прочитать идентификатор S как есть (дословно) в объекте поиска (для строки) или умереть, если там нет такого идентификатора\\
        \verb|[[[указатель]ph]identifier, объект_поиска, R, N]mt|&прочитать любой идентификатор в объекте поиска (для строки) и записать его по указателю (а в R попадает вся конструкция целиком) или умереть, если там нет никакого идентификатора\\
        \verb|[[S]string, объект_поиска, R, N]mt|&прочитать строковую константу S как есть (дословно) в объекте поиска (для строки) или умереть, если там нет такой строковой константы\\
        \verb|[[[указатель]ph]string, объект_поиска, R, N]mt|&прочитать любую строковую константу в объекте поиска (для строки) и записать ее по указателю (а в R попадает вся конструкция целиком) или умереть, если там нет никакой строковой константы\\
        ??????????????????&считывание основных понятий WSEML, таких, как пары и списки, например, через что реализовать компилятор с нужного подмножества C, сразу в машинный код и спискового дублера. Компиляция возможна только для константных подобъектов (каждое поддерево может быть помечено const или mutable, а если никак --- действует пометка ближайшего предка).\\
        \hline
    \end{tabular}
    \end{center}
    Здесь под объектом поиска понимается ссылка на список, состоящий из ссылки на данные и указателя текущей позиции в них. Если данные, соответствующие заказанному шаблону могут быть считаны, начиная с текущей позиции, шаблон заполняется и указатель текущей позиции продвигается соответствующим образом, иначе стек, в котором была вызвана эта команда, удаляется (соответствующий процесс "умирает"\relax.) Если данные, соответствующие заказанному шаблону могут быть считаны несколькими разными способами, стек, в котором была вызвана эта команда, копируется в нужном количестве экземпляров, и в каждый из них возвращается свой результат, и в каждом из них будет своя копия объекта поиска со своим положением указателя текущей позиции (для этого объект поиска должен быть локальным, а указатель на него в составе ссылки --- относительным от текущего стека).

    5) Многостадийное программирование.

    6) Параллелизм (в частности, возможность захватить некоторый объект и отпустить некоторые его подобъекты, почти также, как действуют модификаторы константности).

    7) Мемоизация.

    8) Сетевые указатели.

    9) Язык высокого уровня.

    10) Компиляция.

    11) IDE.

\end{document}
