%! Author = dlebedin
%! Date = 31.01.2022

\documentclass{report}
\usepackage[utf8]{inputenc}
\usepackage[english,russian]{babel}
\setlength{\textheight}{27truecm}
\setlength{\textwidth}{19truecm}
\setlength{\oddsidemargin}{-1.5truecm}
\setlength{\topmargin}{-3truecm}
\begin{document}

    Прежде, чем сформулировать очередное задание, скажем пару слов о том, как вообще устроена наша модель вычислений.

    Центральным для всей модели вычислений является понятие посылки сообщения объекту. Это понятие играет ту же роль, что и оператор (statement) в императивных языках программирования. Оно представляет собой элементарную единицу вычислений. В качестве сообщения может выступать любой объект. Те действия, которые должны при этом выполняться, определяются по таблице реализаций методов (входами таблицы реализаций методов являются наборы из роли объекта, типов объекта и сообщения, режима и меток стека (последние два обсуждаются позже), а выходами --- двухуровневые списки реализаций (начальных кадров, в частности режима, в котором нужно эту реализацию выполнять, а также флаг, показывающий, нужно ли для запуска этой реализации заводить новый стек) и таблице преобразования типов (входами таблицы преобразования типов являются роль, тип, значение которого подлежит преобразованию, и тип, к которму осуществляется преобразование, режим и метки стека, а выходами --- флаг, показывающий, какой из двух участвующих в преобразовании типов отвечает за преобразование, и сообщение, посылка которого соответствующему объекту и выполняет преобразование. Если за преобразование типов отвечает первый тип, т. е. тот, значение из которого преобразуется, соответствующее сообщение посылается этому значению, и результатом является новое значение того типа, к которому выполнялось преобразование. Если же за преобразование типов отвечает второй тип, сообщение может быть послано любому его объекту, и окончательное значение этого объекта после обработки сообщения должно представлять собой преобразованное значение). При этом параллельно запускаются все подходящие варианты, в том числе, с преобразованием типов, но без циклов в этих преобразованиях. Если же таких вариантов нет, запускается специальная процедура по умолчанию, реализация которой также хранится в таблице реализаций методов. При этом, как в ключах этих таблиц, так и в тех объектах, по которым ищется конкретная реализация (значения ключей), допустимы дырки (объект типа plh, играющий роль переменной при унификации, содержащий поле id --- имя такой переменной); соответствие вызова конкретной строке таблицы определяется при помощи унификации, и значения дырок также передаются в найденную реализацию как параметры. Алгоритмы унификации и отслеживания преобразований типов реализуются как набор команд, выполняемых в режиме ядра.

    Двухуровневый список реализаций --- список так называемых гнезд, каждое из которых представляет собой обычный список реализаций. При поиске нужной реализации выдается последняя реализация в первом гнезде. В процессе выполнения этой реализации доступны две команды --- next, запускающая следующую реализацию, т. е., последнюю реализацию в следующем гнезде, и prev, запускающую предыдущую реализацию в текущем гнезде. Каждая реализация представляет собой либо пару из начального стекового кадра списковой реализации и встроенной реализации, если речь идет о реализациях функции sm, и просто начального стекового кадра списковой реализации, для всех остальных строках в таблице. Важным элементом стекового кадра является поле mode, значением которого является режим выполнения данной реализации. В режиме ядра (kernel) все встроенные команды непосредственно выполняются без поиска их реализаций в таблицах, во всех остальных режимах такой поиск имеет место, и режим влияет на его результат как один из входов таблицы реализаций.

    Такая посылка сообщения объекту реализуется при помощи вызова функции sm (ее сигнатура WSEML sm(WSEML)). Этой функции передается список из компактной формы указателей на текущий стековый кадр, на объект, которому посылается сообщение, и на само сообщение. Эта функция проверяет несколько вариантов сочетания свойств объекта и сообщения, и в случае совпадения выполняет действия, необходимые для посылки сообщения. Если ни один из проверяемых вариантов не подошел, выполняется поиск нужной реализации в таблицах и запуск необходимых реализаций оттуда.

    Реализуется такое поведение функции sm с использованием двухуровнего списка реализаций, хранящегося в особой строке таблицы реализации методов. Каждое гнездо этого списка относится к одному варианту сочетания свойств объекта и сообщения, и там хранится встроенная реализация, вместе с начальным кадром для эквивалентной списковой реализации. Каждая из этих реализаций, кроме последней, проверяет свой вариант, и если он подходит, выполняет его, а если нет --- вызывает следующую реализацию. Последняя реализация ищет подходящие варианты в таблице реализаций методов и таблице преобразования типов и запускает все найденные варианты. Для запуска вариантов с преобразованием типов для каждого из таких вариантов строится своя подпрограмма, вызывающая все необходимые преобразования и затем посылку нужному объекту исходного сообщения.

    Все реализации функции sm работают в режиме ядра, т. е. имеющиеся в их составе встроенные команды запускаются без поиска их реализаций в таблицах, непосредственно в процессе работы функции sm.

    Для объяснения дальнейшего необходимо ввести несколько дополнительных понятий. Под подпрограммой мы будем понимать некоторые действия, которые нужно предпринять в определенной ситуации. Под встроенной реализацией подпрограммы понимается обычная функция с сигнатурой WSEML(WSEML). Под представлением встроенной реализации понимается список типа func, состоящий из двух строк --- имени файла динамической библиотеки, содержащей данную функцию, и имени самой функции в этой библиотеке. Под списковой реализацией подпрограммы понимается список любого другого типа (не func).

    Под структурной частью стекового кадра понимается набор его полей, описывающих его положение в стеке (списки непосредственно предыдущих и последующих кадров). Под содержательной частью стекового кадра понимается совокупность остальных его полей и его тип. Списковая реализация обычно представляет собой содержательную часть начального стекового кадра, необходимого для запуска этой реализации. В частности, списковая реализация часто содержит указатель на точку входа, т. е. команду, которая должна быть выполнена первой, в списке команд, представляющем собой тело подпрограммы. В этом случае для запуска такой реализации, кроме начального стекового кадра, нужно еще где-то хранить само тело подпрограммы. Обычно, оно находится где-то внутри поля data.

    Мы говорим, что встроенная реализация подпрограммы является универсальной, если та же подпрограмма имеет эквивалентное тело (которое будет в дальнейшем называться списковым телом), представленное списком команд, т. е. где-то в поле data имеется список команд, выполняющий те же действия, что и соответствующая функция из динамической библиотеки (которую мы будем называть C++-телом подпрограммы). Более того, любое состояние выполнения C++-тела подпрограммы должно иметь эквивалентное состояние выполнения спискового тела, представленное некоторым стековым кадром, который в дальнейшем будет называться эквивалентом этого состояния данной подпрограммы. Смысл эквивалента в том, что если мы выполняем C++-тело подпрограммы до некоторого состояния, а затем помещаем в стек его эквивалент и далее выполняем списковое тело подпрограммы, начиная с эквивалента, результат, включая все побочные эффекты, должен быть тем же самым, как если бы мы выполняли C++-тело подпрограммы до конца.

    Функция sm --- единственная, реализации которой имеют встроенные аналоги. Все остальные функции, состоящие из вызовов встроенных команд, работают в режиме ядра. Режим --- параметр, хранящийся в текущем стековом кадре и определяющий способ выполнения команд, относящихся к данному стековому кадру. Режим ядра --- специальный режим, предполагающий непосредственное выполнение встроенных команд реализациями в составе функции sm, без поиска их реализаций в таблицах. Любой другой режим просто наряду с прочими свойствами команды влияет на поиск ее реализации. Поскольку при вызове sm работают встроенные реализации, при вызове из sm любых команд перед собственно вызовом в стек помещается эквивалент текущего состояния выполнения sm, далее осуществляется вложенный вызов sm, посылающий новому стековому кадру сообщение next, что служит выполнению вызываемой из тела sm команды.

    Результатом функции sm (не путать с результатом самой вызываемой команды, который просто записывается по ссылке на место, куда надо записать результат, стоящей внутри команды) может быть либо COMPLETED, что означает успешное завершение работы команды без вызова списковой реализации каких-либо команд --- в этом случае стековый кадр, созданный непосредственно перед вызовом, удаляется, и sm продолжает свою работу, либо STOPPED, что означает, что в процессе выполнения команды возникла необходимость вызвать команду со списковой реализацией, в случае чего sm сразу приостанавливает свою работу и возвращает STOPPED в вызывающую функцию.

    В классе WSEML есть метод run, с параметром и результатом типа WSEML. Его вызов означает посылку (при помощи вызова функции sm) объекту сообщения типа run со списком из параметра, указанного при вызове метода run и ссылки на тот объект, которому нужно присвоить результат. Встроенная реализация процедуры обработки этого сообщения проверяет, есть ли у объекта поле stacks, и если его нет, заводит его, присваивая ему некоторое начальное значение, указанное далее. Затем этому объекту посылается сообщение типа next без параметра, до тех пор, пока оно не вернет false в качестве результата; это происходит тогда, когда либо встречается специальная команда stop, либо вычисления заканчиваются (удаляется последний стек). В обоих случаях считывается результат и возвращается в качестве результата вызова метода run. При этом, ролью корневого объекта всегда считается идентификатор root.

    Функция sm, в случае, если объекту посылается сообщение типа next, направляет это сообщение стековому кадру (вызывая ту же функцию sm, но с другими параметрами), и после этого завершается. Вложенный вызов sm, если стековый кадр стандартен (роль frm, тип dfa (стандартный тип стекового кадра для выполнения списковых реализаций)), посылает текущей команде сообщение типа exec.

    Если же встроенной команде посылается exec в режиме ядра (что обнаруживается при помощи соответствующей реализации sm), такая команда выполняется (той же реализацией sm). Вообще говоря, выделение режима ядра для непосредственно выполняемых команд произвольно. Просто есть набор ситуаций вызова, в том числе режимов, которые проверяются плагинами к sm, и в случае совпадения такие команды выполняются сразу, без поиска по таблице.

    В классе WSEML имеется статическое поле такого же класса, т. е. тип его тоже WSEML. В нем содержатся таблицы реализации методов и преобразования типов.

    %Локальные части таблиц (т. е. в объекте?)

    Для объяснения дальнейшего нужно рассмотреть понятие ссылки, потому что ссылки могут использоваться как параметры команд.

    Ссылка --- список, тип которого состоит из идентификатора ref и еще одного объекта, показывающего разновидность ссылки. Если это не список, то это сама разновидность ссылки, иначе --- список разновидностей ссылок, применяемых последовательно.

    Каждая разновидность ссылки может получать два типа сообщений:  чтение из нее и запись в нее. Кроме полей, описывающих то место, на которое она ссылается, она имеет поле context, в котором хранится указатель на тот стековый кадр, в котором выполняется та реализация, в которой эта ссылка записана. Операция чтения ссылки кладет значение, полученное из ссылки на вершину стека данных, расположенного в текущем стековом кадре. Операция записи берет значение с вершины этого стека и записывает его по ссылке.

    Встроенными разновидностями ссылок являются следующие:

    i --- такая ссылка ссылается на свое поле данных с ключом value, именно его содержимое читается и записывается по данной ссылке, даже если это поле содержит другую ссылку, она не разыменовывается и воспринимается так, как записана в этом поле.

    d --- такая ссылка содержит указатель в поле ptr и ссылается на то, на что указывает этот указатель, в качестве которого тоже может выступать другая ссылка, и она тоже разыменовывается.

    f --- ссылка на текущий cтековый кадр, определяется полем context.

    с --- ссылка на текущую команду, если нет параметров, и поле текущей команды, если указан его ключ.

    Следующие команды должны быть реализованы как встроенные реализации команды sm (в нижеприведенной таблице под R понимается ссылка на то, куда надо поместить результат, O, O1, O2 --- ссылки на операнды, N --- шаг указателя на следующую команду, под P1 и далее понимаются так называемые параметры ветвления; стековый кадр, в котором встретилась такая команда, должен быть скопирован, чтобы в итоге получилось M копий, в каждой из которых по указателю R записывается значение очередного параметра ветвления. В качестве R должен выступать указатель относительно текущего стекового кадра, т. е. список типа ptr, состоящий из шагов указателя, применяемых начиная с указателя на текущий стековый кадр):

    \begin{tabular}{|l|p{10cm}|}
        \hline
        Синтаксис&Смысл команды\\
        \hline
        \verb|[куда, что, N]`:='|&присваивание\\
        \hline
        \verb|[R, O1, O2, N]`+'|&сложение чисел, содержащихся в строках\\
        \verb|[R, O1, O2, N]`-'|&вычитание чисел, содержащихся в строках\\
        \verb|[R, O1, O2, N]`*'|&умножение чисел, содержащихся в строках\\
        \verb|[R, O1, O2, N]`/'|&деление чисел, содержащихся в строках\\
        \verb|[R, O1, O2, N]`%'|&остаток от деления чисел, содержащихся в строках\\
        \verb|[R, O1, O2, N]`^'|&возведение в степень чисел, содержащихся в строках\\
        \verb|[R, O1, O2, N]`.'|&конкатенация строк или списков\\
        \hline
        \verb|[R, O1, O2, N]`='|&проверка равенства объектов\\
        \verb|[R, O1, O2, N]`!='|&проверка отсутствия равенства объектов\\
        \verb|[R, O1, O2, N]`<'|&проверка отношения меньше\\
        \verb|[R, O1, O2, N]`>'|&проверка отношения больше\\
        \verb|[R, O1, O2, N]`<='|&проверка отношения меньше или равно\\
        \verb|[R, O1, O2, N]`>='|&проверка отношения больше или равно\\
        \hline
        \verb|[R, O1, O2, N]`&&'|&логическое и\\
        \verb+[R, O1, O2, N]`||'+&логическое или\\
        \verb|[R, O, N]`!'|&логическое не\\
        \hline
        \verb|[R, L, RK, K, RD, D, I, N]I|&вставить элемент с ключом K и ролью ключа RK, данными D и ролью данных RD в список или строку L в позицию I \\
        \verb|[указатель, N]D|&удалить элемент из списка или строки\\
        \verb|[R, указатель, N]E|&проверить, что указатель может быть разыменован\\
        \verb|[R, функция, N]C|&вызвать встроенную (чисто встроенную или универсальную) реализацию\\
        \verb|[R, указатель, N]P|&преобразовать последний шаг указателя к i\\
        \verb|[R, указатель, N]K|&преобразовать последний шаг указателя к k\\
        \verb|[R, N]prev|&запустить предыдущую реализацию подпрограммы, выполняющейся в текущем стековом кадре. При этом, создается новый кадр или стек (в зависимости от значения флага, показывающего, нужно ли для этой реализации заводить новый стек), который будет находиться между текущим и всеми непосредственно предыдущими, т. е. непосредственно предшествовать текущему, и непосредственно последовать за всеми теми, которые непосредственно предшествовали текущему до выполнения этой операции; у нового кадра или стека поле origin в info будет иметь значение backward; результатом этой команды будет ключ вновь создаваемого кадра (стека). Содержательная часть нового кадра (единственного кадра нового стека) берется, как у запускаемой реализации в таблице реализаций\\
        \verb|[R, N]next|&аналогично, запустить следующую реализацию подпрограммы, работающей в данном стековом кадре (для нее создается новый стековый кадр между текущим и всеми непосредственно последующими)\\
        \verb|[R, O, N]T|&считать тип объекта\\
        \verb|[R, O, N]S|&установить тип объекта\\
        \hline
        \verb|[условие, N1, N2]`?'|&условная команда\\
        \hline
        \verb|[список_стековых_кадров]F|&разветвление выполнения\\
        %\verb|[R, A, N]c|&вызвать подпрограмму со списковой реализацией\\
        \verb|[R, O, N]R|&вернуть результат O в вызывавшую подпрограмму (предыдущий стековый кадр), не уничтожая при этом текущего стекового кадра, если есть поле N, а если его нет, то уничтожить ; если в предыдущем стековом кадре будет вызвана команда r, ее операнд запишется в R\\
        \verb|[R, O, N]r|&возобновить выполнение вызванной подпрограммы, выполнение которой было прервано по команде `R', записав операнд команды `r' в результат этой команды `R', до следующей такой команды в ней (операнд в которой будет записан в R данной команды `r'), или команды `x'\\
        \verb|[]x|&уничтожить текущий стековый кадр\\
        \verb|[]X|&уничтожить текущий стек\\
        \verb|[R, O1, O2, N]Z|&получить ключ стека, ответвившегося от стека с ключом O1, с параметром ветвления (ключом в списке стеков?) O2\\
        \verb|[R, O, N]z|&получить последовательность параметров ветвления для стека с ключом O от начального стека\\
        \verb|[R, N]next_body|&следующая реализация (как ее найти? хранить в реализации или в стековом кадре поле с ключом fsf first stack frame, указывающее на начальный стековый кадр (в таблице реализаций) работающей в данном кадре реализации)
        \verb|[R, K, N]next_cmd|&следующая команда в вызывавшей реализации (если есть K, то берется содержимое поля с таким ключом; если его нет, то с ключом next; а как найти правильный стековый кадр? найти реализацию, в которой содержится данная команда, затем стековый кадр, в котором она выполняется, и, наконец, стековый кадр, из которго она вызвана --- как правило, предыдущий; в реализации команды указывается, стандартный ли переход к следующей команде используется, или нет, и если да, то это делается автоматически, иначе ничего не делается, и реализация команды делает это самостоятельно; иначе возникает бесконечная рекурсия)
        \hline
    \end{tabular}

    В качестве начального значения поля stck используется следующее:

    \begin{verbatim}
    {
        // поле, содержащее настройки и общую информацию обо всем наборе стеков
        info:{

            // список ключей рабочих стеков (остальные заморожены и активного участия в вычислениях не
            // принимают; очередной шаг делается в стеке, чей ключ идет здесь первым; в начале имеется
            // только один стек, и он рабочий)
            wlist:{1:1},

            // включена ли ротация стеков (если она включена, то после очередного шага ключ первого
            // рабочего стека, того, в котором был сделан очередной шаг, перемещается в конец данного
            // списка, если он не был удален на этом шаге)
            rot:true
            },

        // собственно начальный рабочий стек
        1:{
            // поле, содержащее настройки и общую информацию об этом стеке
            info:{

                // метки стека, могут участвовать в выборе реализаций той или иной команды в сщщтветствии с таблицами
                // реализации методов или преобразования типов
                labels:{},

                // список ключей рабочих кадров (в одном стеке их может быть несколько)
                wfrm:{1:1},

                // включена ли ротация кадров данного стека
                rot:true,

                // список ключей непосредственно предыдущих стеков (набор стеков организован, как
                // бесконтурный ориентированный граф, и в этом поле хранится список ключей тех стеков,
                // в которые имеются дуги из этого стека)
                prev:{},

                // список ключей непосредственно следующих стеков в графе стеков, т. е. стеков, из которых
                // имеются дуги в этот стек
                next:{},

                // показывает то, как был создан данный стек (возможные варианты значений --- first, стек был
                // первым, forward --- стек был создан при помощи "шага вперед", в том направлении, в котором
                // обычно растет стек, backward --- стек был создан при помощи "шага назад", в направлении,
                // противоположном тому, в котором обычно растет стек. Значение этого поля определяет, что
                // происходит при уничтожении стека: если значение этого поля --- forward, то при уничтожении
                // этого стека рабочими становятся те стеки, ключи которых лежат в поле prev, если backward ---
                // в поле next. Стек со значением этого поля first в любом случае должен уничтожаться последним,
                // нарушение этого правила считается ошибкой, приводящей к аварийному завершению программы
                origin: first
                },

            // собственно начальный рабочий кадр
            1:frm[
                ip:указатель_на_текущую_команду, // содержательная часть стекового кадра
                mode:режим,
               prev:{}, // список ключей предыдущих стековых кадров
               next:{}, // аналогично следующих
               origin:first // происхождение данного стекового кадра --- как для стеков, только для кадров внутри одного
               // стека
                ]dfa
        }
    }
    \end{verbatim}

    Задание 5. Реализовать предложенную в этом файле модель вычислений.

\end{document}
